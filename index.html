<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hello Phaser Test</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <style>
    body { margin:0; background:#111; color:white; }
    canvas { display:block; margin:auto; }
  </style>
</head>
<body>
  <h3 style="text-align:center;">Phaser Hello World</h3>

<script>
  console.log("‚úÖ Phaser WFC script with regeneration loaded");

class WaveFunctionCollapse {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.tiles = ["water", "land"];

    // Rule weights: preference for similar neighbors
    this.rules = {
      water: { water: 0.8, land: 0.2 },
      land:  { land: 0.8,  water: 0.2 }
    };
  }

  // Generate grid obeying adjacency preferences
  generate() {
    const grid = Array.from({ length: this.height }, () =>
      Array.from({ length: this.width }, () => ({
        tile: null,
        entropy: 1.0
      }))
    );

    // start with random seed in center
    const startX = Math.floor(this.width / 2);
    const startY = Math.floor(this.height / 2);
    grid[startY][startX].tile = Math.random() < 0.5 ? "water" : "land";

    // propagate outward
    const dirs = [
      [1, 0], [-1, 0], [0, 1], [0, -1]
    ];

    const queue = [[startX, startY]];
    while (queue.length > 0) {
      const [x, y] = queue.shift();
      const currentTile = grid[y][x].tile;

      for (const [dx, dy] of dirs) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx < 0 || ny < 0 || nx >= this.width || ny >= this.height) continue;

        if (!grid[ny][nx].tile) {
          // decide based on current neighbor's bias
          const probs = this.rules[currentTile];
          const rand = Math.random();
          const nextTile = rand < probs.water ? "water" : "land";
          grid[ny][nx].tile = nextTile;
          queue.push([nx, ny]);
        }
      }
    }

    // fill any remaining nulls randomly (edges)
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        if (!grid[y][x].tile) grid[y][x].tile = Math.random() < 0.5 ? "water" : "land";
      }
    }

    // return 2-D array of tile strings
    return grid.map(row => row.map(c => c.tile));
  }
// approximate entropy visualization (0=stable, 1=uncertain)

visualizeEntropy(scene, grid) {
  const size = 32;
  const overlay = scene.add.graphics();

  for (let y = 0; y < this.height; y++) {
    for (let x = 0; x < this.width; x++) {
      const tile = grid[y][x];
      // Randomized approximation of entropy level
      const entropy = 0.2 + Math.random() * 0.8;  // full range 0.2‚Äì1.0

      // Interpolate between Red ‚Üí Yellow ‚Üí Blue
      // We'll use two phases: Red‚ÜíYellow for high entropy, Yellow‚ÜíBlue for low
      let color;
      if (entropy > 0.5) {
        color = Phaser.Display.Color.Interpolate.ColorWithColor(
          new Phaser.Display.Color(255, 0, 0),      // red
          new Phaser.Display.Color(255, 255, 0),    // yellow
          1, entropy - 0.5
        );
      } else {
        color = Phaser.Display.Color.Interpolate.ColorWithColor(
          new Phaser.Display.Color(255, 255, 0),    // yellow
          new Phaser.Display.Color(0, 0, 255),      // blue
          1, entropy * 2
        );
      }

      const hex = Phaser.Display.Color.GetColor(color.r, color.g, color.b);
      overlay.fillStyle(hex, 0.2); // lighter transparency to reveal terrain
      overlay.fillRect(x * size, y * size, size, size);
    }
  }

  // Store overlay so it can be cleared before regenerating
  this.overlay = overlay;
}

}
window.WaveFunctionCollapse = WaveFunctionCollapse;

  const config = {
    type: Phaser.AUTO,
    width: 640,
    height: 480,
    backgroundColor: "#0b1020",
    pixelArt: true,
    scene: { preload, create }
  };

  new Phaser.Game(config);

  function preload() {
    this.textures.generate("water", { data: ["2"], pixelWidth: 32, palette: { 2: "#2e8bff" } });
    this.textures.generate("land",  { data: ["1"], pixelWidth: 32, palette: { 1: "#55aa33" } });
  }

  function create() {
    console.log("üé¨ Scene create() running");

    this.w = 20;
    this.h = 15;
    this.tileSize = 32;

    // function to generate + draw grid
    this.generateMap = () => {
      if (this.tiles) this.tiles.forEach(t => t.destroy());
      const wfc = new WaveFunctionCollapse(this.w, this.h);
      const grid = wfc.generate();
      this.tiles = [];
      for (let y = 0; y < this.h; y++) {
        for (let x = 0; x < this.w; x++) {
          const tile = this.add.image(
            x * this.tileSize + this.tileSize / 2,
            y * this.tileSize + this.tileSize / 2,
            grid[y][x]
          );
          this.tiles.push(tile);
        }
      }
      wfc.visualizeEntropy(this, grid);
    };

    // first draw
    this.generateMap();

    // R key regenerates
    this.input.keyboard.on("keydown-R", () => {
      console.log("üîÅ Regenerating map...");
      this.generateMap();
    });

    this.add.text(10, 460, "Press R to regenerate", { fontSize: "16px", fill: "#fff" });
  }
</script>


</body>
</html>

